include "persistence.conf"

akka {

  loglevel = INFO

  discovery.method = akka-dns

  http.server.default-host-header = "cfpb.gov"
  http.parsing.max-content-length = 1G

  actor {
    provider = "cluster"
  }

  cluster {
    failure-detector.threshold = 12
    metrics.enabled = off
    downing-provider-class = "tanukki.akka.cluster.autodown.MajorityLeaderAutoDowning"
  }

  remote {
    netty.tcp {
      hostname = ${?HOST}
      port = 2551
      port = ${?PORT_2551}

      bind-hostname = 0.0.0.0
      bind-port = 2551
    }
  }

  custom-downing {
    stable-after = 10s
    stable-after = ${?CUSTOM_DOWNING_STABLE_AFTER}

    majority-leader-auto-downing {
      majority-member-role = ""
      down-if-in-minority = true
      shutdown-actor-system-on-resolution = true
    }
  }

  management {
    http {
      # The hostname where the HTTP Server for Http Cluster Management will be started.
      # This defines the interface to use.
      # InetAddress.getLocalHost.getHostAddress is used not overriden or empty
      hostname = ${?HOST}
      port = 19999
      port = ${?PORT_19999}

      bind-hostname = 0.0.0.0
      bind-port = 19999
    }

    cluster {
      bootstrap {
        # Configuration for the first phase of bootstraping, during which contact points are discovered
        # using the configured service discovery mechanism (e.g. DNS records).
        contact-point-discovery {

          # Define this name to be looked up in service discovery for "neighboring" nodes
          # If undefined, the name will be extracted from the ActorSystem name
          service-name = ${?MARATHON_APP_ID}

          # Added as suffix to the service-name to build the effective-service name used in the contact-point service lookups
          # If undefined, nothing will be appended to the service-name.
          #
          # Examples, set this to:
          # "default.svc.cluster.local" or "my-namespace.svc.cluster.local" for kubernetes clusters.
          service-namespace = "marathon.mesos"

          # The effective service name is the exact string that will be used to perform service discovery.
          #
          # Set this value to a specific string to override the default behaviour of building the effective name by
          # concatenating the `service-name` with the optional `service-namespace` (e.g. "name.default").
          effective-name = ${?SERVICE_NAME}
        }

        # Configured how we communicate with the contact point once it is discovered
        contact-point {
          # If no port is discovered along with the host/ip of a contact point this port will be used as fallback
          fallback-port = 19999
          fallback-port = ${?PORT_19999}
        }

      }
    }
  }

}

hmda {
  cluster.name = "hmda2"
  runtime.mode = "dev"
  runtime.mode = ${?HMDA_RUNTIME_MODE}
  http {
    filingHost = "0.0.0.0"
    filingHost = ${?HMDA_HTTP_HOST}
    adminHost = "0.0.0.0"
    adminHost = ${?HMDA_HTTP_ADMIN_HOST}
    publicHost = "0.0.0.0"
    publicHost = ${?HMDA_HTTP_PUBLIC_HOST}
    filingPort = 8080
    filingPort = ${?HMDA_HTTP_PORT}
    adminPort = 8081
    adminPort = ${?HMDA_HTTP_ADMIN_PORT}
    publicPort = 8082
    publicPort = ${?HMDA_HTTP_PUBLIC_PORT}
    timeout = 10
    timeout = ${?HMDA_HTTP_TIMEOUT}
  }

  ws {
    host = "0.0.0.0"
    host = ${?WS_HOST}
    port = 9080
    port = ${?WS_PORT}
  }

  filing {
    ts.length = 15
    lar.length = 110
  }
  institutions {
    shardNumber = 100
  }
}
